<!DOCTYPE html>

<title>Dragging Demo</title>
<style>
canvas {
	border: 5px solid black;
}
</style>

<img src="hukidashi1.png" id="idontwannalose" hidden>

<canvas id="gameCanvas"></canvas>

<script>
/*
example elements:
square
circle
crate (image)
frame count (backless image)
face (path with cutout)
*/

var idontwannalose = document.getElementById("idontwannalose");

var canvas = document.getElementById("gameCanvas");
canvas.height = 500;
canvas.width = 750;
var ctx = canvas.getContext("2d");

ctx.miterLimit = 2;

function ease(variable, upwards, increment, lowerBound, upperBound){
	var number = variable;
	if(upwards){
		number += increment;
		if (number > upperBound){number = upperBound}
	}
	else{
		number -= increment;
		if (number < lowerBound){number = lowerBound}
	}
	return number;
}

function fillAndStrokeText(text, x, y){
	ctx.strokeText(text, x, y);
	ctx.fillText(text, x, y);
}

function drawBox(x, y, w, h, color, borderWidth = false, borderColor = "black", text = false, textColor = "white", font = "bold 10px sans-serif"){
	var fontSize = parseInt(ctx.font.match(/\d+/), 10);
	if(borderWidth){
		ctx.strokeStyle = borderColor;
		ctx.lineWidth = borderWidth;
		ctx.strokeRect(x,y, w,h);
	}
	ctx.fillStyle = color;
	ctx.fillRect(x,y, w,h);
	if(text){
		ctx.font = font;
		ctx.fillStyle = textColor;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";		
		ctx.fillText(text, x + w/2, y + h/2 + 1);		
		ctx.textAlign = "left";
	}		
}

function breakTextIntoLines(string, width){
	var offset = 0;
	var lines = [];
	var i = 0;
	for (i = 0; i < string.length; i++){
		if (ctx.measureText(string.slice(offset, i)).width > width){
			var lineEnd = string.slice(0, i).lastIndexOf(" ") + 1;
			var line = string.slice(offset, lineEnd);
			lines.push(line);
			offset = lineEnd;
		}
	}
	lines.push(string.slice(offset));
	return lines;
}

function drawTextLines(x, y, lines, drawType = "fill"){
	var fontHeight = parseInt(ctx.font.match(/\d+/), 10);
	var i = 0;
	if(drawType == "fill"){
		for(i = 0; i < lines.length; i++){					
			ctx.fillText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
	else if(drawType == "stroke"){
		for(i = 0; i < lines.length; i++){					
			ctx.strokeText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
	else if(drawType == "both"){
		for(i = 0; i < lines.length; i++){
			ctx.strokeText(lines[i], x, y + i * 1.75 * fontHeight);	
			ctx.fillText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
}

class Button {
	constructor(x, y, w, h, color, border = false, text = false, textColor, font){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.color = color;
		if(border){this.border = border;}
		if(text){
			this.text = text;
			this.textColor = textColor;
			this.font = font;
		}
	}
	render(){
		if(this.text){drawBox(this.x, this.y, this.w, this.h, this.color, this.border, "black", this.text, this.textColor, this.font);}
		else {drawBox(this.x, this.y, this.w, this.h, this.color, this.border, "black");}
	}
	checkClick(mx, my){
		if(this.x < mx && mx < this.x + this.w && this.y < my && my < this.y + this.h){
			return true;
		}
		else {
			return false;
		}
	} 
}

class Shape {
	constructor(type, color, borderWidth, borderColor, data, x, y, ...dimensions){
		this.type = type;
		if(color){this.color = color;}
		if(borderWidth){this.borderWidth = borderWidth;}
		if(borderColor){this.borderColor = borderColor;}
		this.x = x;
		this.y = y;

		if(type == "rectangle" || type == "image"){
			this.w = dimensions[0];
			this.h = dimensions[1];
			if(type == "image"){this.imageData = data;}
		}
		else if (type == "circle"){
			this.r = dimensions[0];
		}
		else if (type == "path"){this.path = data;}
	}
	render(offsetX, offsetY){
		if(this.type == "rectangle"){
			drawBox(this.x + offsetX, this.y + offsetY, this.w, this.h, this.color, this.borderWidth, this.borderColor);
		}
		else if(this.type == "circle"){
			ctx.beginPath();
			ctx.arc(this.x + offsetX, this.y + offsetY, this.r, 0, 2*Math.PI);
			if (this.color){ctx.fillStyle = this.color; ctx.fill();}
			if (this.borderWidth){
				ctx.lineWidth = this.borderWidth;
				ctx.fillStyle = this.borderColor;
				ctx.stroke();
			}
		}
		else if(this.type == "image"){
			ctx.drawImage(this.imageData, this.x + offsetX, this.y + offsetY, this.w, this.h);
		}
		else if(this.type == "path"){
			if (this.color){
				ctx.fillStyle = this.color; 
				ctx.save(); 
				ctx.translate(this.x + offsetX, this.y + offsetY);
				ctx.fill(this.path);
				ctx.restore();
			}
			if (this.borderWidth){
				ctx.lineWidth = this.borderWidth; 
				ctx.fillStyle = this.borderColor;
				ctx.save();
				ctx.translate(this.x + offsetX, this.y + offsetY);
				ctx.stroke(this.path);
				ctx.restore();
			}
		}
	}
	checkClick(mx, my, offsetX, offsetY){
		var x = offsetX ? this.x + offsetX : this.x;
		var y = offsetY ? this.y + offsetY : this.y;
		//type based collison checking, for paths use subtract and point in path.
		if(this.type == "rectangle" || this.type == "image"){
			if(x < mx && mx < x + this.w && y < my && my < y + this.h){
				return true;
			}
			else {
				return false;
			}
		}
		if(this.type == "circle"){
			if(Math.sqrt( Math.pow((x - mx), 2) + Math.pow((y - my), 2)) < this.r){
				return true;
			}
			else {	
				return false;
			}
			
		}
		if(this.type == "path"){
			ctx.translate(x, y);
			var hit = ctx.isPointInPath(this.path,mx,my);
			ctx.translate(-x, -y);
			return hit;
		}
	}
}
/*
add rotation and opacity
*/

class MenuElement {
	constructor(x, y, shapes, text = false, collider = false){
		this.x = x;
		this.y = y;
		//data consists of a shape type and data.
		this.shapes = shapes;
		if (collider) {this.collider = collider;}
		else {
			if(Array.isArray(shapes)){this.collider = shapes[0];}
			else {this.collider = shapes;}
		}

		if(text){
			this.text = text[0];
			this.textColor = text[1];
			this.font = text[2];
		}
		else {
			this.text = false;
		}
	}
	render(){
		//change this to have shapes and shape initialized under diiferent conditions.
		if(Array.isArray(this.shapes)){
			var shape = 0;
			for (shape of this.shapes){
				shape.render(this.x, this.y);
			}
		}
		else {
			this.shapes.render(this.x, this.y);
		}
	
		if(this.text){
			ctx.font = this.font;
			ctx.fillStyle = this.textColor;
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(this.text, this.x + this.collider.x + this.collider.w/2, this.y + this.collider.y + this.collider.w/2);		
			ctx.textAlign = "left";
		}
	}
	checkClick(mx, my){
		return this.collider.checkClick(mx, my, this.x, this.y);
	} 
}

//var draggable = new Button(0,0,100,25, "brown", 7, "drag me", "white", "10px sans-serif");

var testShape = new Shape("rectangle","green",7,"black", false, 30,30,30,30);
var testShape2 = new Shape("circle","blue",4,"black", false, 30,30,20);

var draggable = new MenuElement(0, 0, [testShape, testShape2], ["drag me", "grey", "20px sans-serif"]);

//draggable.render();

var frameNum = 0;
var pressing = false;
var holding = false;
var mx = 0;
var my = 0;
var offX = 0;
var offY = 0;

function parseClick(e){
	pressing = true;
	if(draggable.checkClick(mx, my)){
		holding = draggable; 
		offX = e.offsetX - draggable.x;
		offY = e.offsetY - draggable.y;
	} //check collision and fill with object later
}

function parseMove(e){
	mx = e.offsetX;
	my = e.offsetY;
	
	mouseX = mx;
	mouseY = my;
	//if holding, move according to mousePos
	
	if(holding){
		holding.x = mx - offX;
		holding.y = my - offY;
	}
}

function parseRelease(e){
	//var mx = e.offsetX;
	//var my = e.offsetY;
	pressing = false;
	holding = false;
}

function refresh(){	
    ctx.clearRect(0, 0, canvas.width, canvas.height);
	draggable.render();
	testShape.render();
	//fill this with render commands
	fillAndStrokeText("Frames: " + frameNum, 500, 250);
    frameNum++;
	requestAnimationFrame(refresh);	
}

document.addEventListener("mousedown", parseClick);
document.addEventListener("mousemove", parseMove);
document.addEventListener("mouseup", parseRelease);
requestAnimationFrame(refresh);
</script>