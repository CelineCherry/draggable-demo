<!DOCTYPE html>

<title>Dragging Demo</title>
<style>
canvas {
	border: 5px solid black;
}
</style>

<img src="hukidashi1.png" id="idontwannalose" hidden>

<canvas id="gameCanvas"></canvas>

<script>
/*
example elements:
square
circle
crate (image)
frame count (backless image)
face (path with cutout)

# add text as a type of shape? needs x, y, text (str or array), borderWidth, borderColor, color, width
straighten out text and collider init code.
add rotation and opacity, rotation addative
fix border and text slicing
*/

var idontwannalose = document.getElementById("idontwannalose");

var canvas = document.getElementById("gameCanvas");
canvas.height = 500;
canvas.width = 750;
var ctx = canvas.getContext("2d");

ctx.miterLimit = 2;

function ease(variable, upwards, increment, lowerBound, upperBound){
	var number = variable;
	if(upwards){
		number += increment;
		if (number > upperBound){number = upperBound}
	}
	else{
		number -= increment;
		if (number < lowerBound){number = lowerBound}
	}
	return number;
}

function fillAndStrokeText(text, x, y){
	ctx.strokeText(text, x, y);
	ctx.fillText(text, x, y);
}

function breakTextIntoLines(string, width){
	var offset = 0;
	var lines = [];
	var i = 0;
	for (i = 0; i < string.length; i++){
		if (ctx.measureText(string.slice(offset, i)).width > width){
			var lineEnd = string.slice(0, i).lastIndexOf(" ") + 1;
			var line = string.slice(offset, lineEnd);
			lines.push(line);
			offset = lineEnd;
		}
	}
	lines.push(string.slice(offset));
	return lines;
}

function drawTextLines(x, y, lines, drawType = "fill"){
	var fontHeight = parseInt(ctx.font.match(/\d+/), 10);
	var i = 0;
	if(drawType == "fill"){
		for(i = 0; i < lines.length; i++){					
			ctx.fillText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
	else if(drawType == "stroke"){
		for(i = 0; i < lines.length; i++){					
			ctx.strokeText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
	else if(drawType == "both"){
		for(i = 0; i < lines.length; i++){
			ctx.strokeText(lines[i], x, y + i * 1.75 * fontHeight);	
			ctx.fillText(lines[i], x, y + i * 1.75 * fontHeight);
		}
	}
}

class Shape {
	constructor(type, color, borderWidth, borderColor, data, x, y, ...dimensions){
		this.type = type;
		if(color){this.color = color;}
		if(borderWidth){this.borderWidth = borderWidth;}
		if(borderColor){this.borderColor = borderColor;}
		this.x = x;
		this.y = y;

		if(type == "rectangle" || type == "image"){
			this.w = dimensions[0];
			this.h = dimensions[1];
			if(type == "image"){this.imageData = data;}
		}
		else if (type == "circle"){
			this.r = dimensions[0];
		}
		else if (type == "path"){this.path = data;}
		else if (type == "text"){
			this.font = dimensions[0];
			if(dimensions[1]){
				this.w = dimensions[1];
				ctx.font = this.font;
				this.text = breakTextIntoLines(data, this.w);
				ctx.textBaseline = "top";
				this.h = ctx.measureText(this.text[0]).actualBoundingBoxDescent*this.text.length*1.25;
			}
			else {
				this.text = data;
				ctx.font = this.font;
				ctx.textBaseline = "top";
				this.w = ctx.measureText(this.text).width;
				this.h = ctx.measureText(this.text).actualBoundingBoxDescent;
				
			}
		}
	}
	render(offsetX, offsetY){
		var x = offsetX ? this.x + offsetX : this.x;
		var y = offsetY ? this.y + offsetY : this.y;

		if(this.type == "rectangle"){
			if(this.borderWidth){
				ctx.strokeStyle = this.borderColor;
				ctx.lineWidth = this.borderWidth;
				ctx.strokeRect(x,y, this.w,this.h);
			}
			ctx.fillStyle = this.color;
			ctx.fillRect(x,y, this.w,this.h);
		}
		else if(this.type == "circle"){
			ctx.beginPath();
			ctx.arc(x, y, this.r, 0, 2*Math.PI);
			if (this.color){ctx.fillStyle = this.color; ctx.fill();}
			if (this.borderWidth){
				ctx.lineWidth = this.borderWidth;
				ctx.fillStyle = this.borderColor;
				ctx.stroke();
			}
		}
		else if(this.type == "image"){
			ctx.drawImage(this.imageData, x, y, this.w, this.h);
		}
		else if(this.type == "path"){
			if (this.color){
				ctx.fillStyle = this.color; 
				ctx.save(); 
				ctx.translate(x, y);
				ctx.fill(this.path);
				ctx.restore();
			}
			if (this.borderWidth){
				ctx.lineWidth = this.borderWidth; 
				ctx.fillStyle = this.borderColor;
				ctx.save();
				ctx.translate(x, y);
				ctx.stroke(this.path);
				ctx.restore();
			}
		}
		else if (this.type == "text"){
			ctx.font = this.font;
			if(Array.isArray(this.text)){
				var fontHeight = parseInt(ctx.font.match(/\d+/), 10);
				var i = 0;
				if(this.borderWidth){
					ctx.lineWidth = this.borderWidth;
					ctx.fillStyle = this.borderColor;
					for(i = 0; i < this.text.length; i++){					
						ctx.strokeText(this.text[i], x, y + i * 1.25 * fontHeight);
					}
				}
				if(this.color){
					ctx.fillStyle = this.color;
					for(i = 0; i < this.text.length; i++){					
						ctx.fillText(this.text[i], x, y + i * 1.25 * fontHeight);
					}
				}
			}
			else {
				if(this.borderWidth){
					ctx.lineWidth = this.borderWidth;
					ctx.fillStyle = this.borderColor;	
					ctx.strokeText(this.text, x, y);
				}
				if(this.color){			
					ctx.fillStyle = this.color;	
					ctx.fillText(this.text, x, y);
				}
			}
		}
	}
	checkClick(mx, my, offsetX, offsetY){
		var x = offsetX ? this.x + offsetX : this.x;
		var y = offsetY ? this.y + offsetY : this.y;
		//type based collison checking, for paths use subtract and point in path.
		if(this.type == "rectangle" || this.type == "image"){
			if(x < mx && mx < x + this.w && y < my && my < y + this.h){
				return true;
			}
			else {
				return false;
			}
		}
		if(this.type == "circle"){
			if(Math.sqrt( Math.pow((x - mx), 2) + Math.pow((y - my), 2)) < this.r){
				return true;
			}
			else {	
				return false;
			}
			
		}
		if(this.type == "path"){
			ctx.translate(x, y);
			var hit = ctx.isPointInPath(this.path,mx,my);
			ctx.translate(-x, -y);
			return hit;
		}
	}
}

class VisualElement {
	constructor(x, y, shapes, collider = false){
		this.x = x;
		this.y = y;
		this.shapes = shapes;
		if (collider) {this.collider = collider;} // add special case for when collider is an index of shapes.
		else {
			if(Array.isArray(shapes)){this.collider = shapes[0];}
			else {this.collider = shapes;}
		}
	}
	render(){
		if(Array.isArray(this.shapes)){
			var shape = 0;
			for (shape of this.shapes){
				shape.render(this.x, this.y);
			}
		}
		else {
			this.shapes.render(this.x, this.y);
		}
	}
	checkClick(mx, my){
		return this.collider.checkClick(mx, my, this.x, this.y);
	} 
}

var examplePath = new Path2D("M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50");

var testShape = new Shape("image","green",7,"black", idontwannalose, 0,0,200,100);
var testShape2 = new Shape("text","pink",3,"black", "Wow, another liberal complaning about the health of care...", -100, 100, "30px serif");
var testShape3 = new Shape("text","blue",3,"black", "Joe many liberals does it take to change a log by bulb??? Their Gender", -100, 100 + testShape2.h, "30px serif", 400, "End-aligned", "middle");

var draggable = new VisualElement(200, 200, [testShape, testShape2, testShape3]);

var frameNum = 0;
var pressing = false;
var holding = false;
var mx = 0;
var my = 0;
var offX = 0;
var offY = 0;

function parseClick(e){
	pressing = true;
	if(draggable.checkClick(mx, my)){
		holding = draggable; 
		offX = e.offsetX - draggable.x;
		offY = e.offsetY - draggable.y;
	} //check collision and fill with object later
}

function parseMove(e){
	mx = e.offsetX;
	my = e.offsetY;
	
	mouseX = mx;
	mouseY = my;
	//if holding, move according to mousePos
	
	if(holding){
		holding.x = mx - offX;
		holding.y = my - offY;
	}
}

function parseRelease(e){
	//var mx = e.offsetX;
	//var my = e.offsetY;
	pressing = false;
	holding = false;
}

function refresh(){	
    ctx.clearRect(0, 0, canvas.width, canvas.height);
	draggable.render();
	testShape2.text = "Frames: " + frameNum;
    frameNum++;
	requestAnimationFrame(refresh);	
}

document.addEventListener("mousedown", parseClick);
document.addEventListener("mousemove", parseMove);
document.addEventListener("mouseup", parseRelease);
requestAnimationFrame(refresh);
</script>